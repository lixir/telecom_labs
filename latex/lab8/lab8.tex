\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\usepackage{here}
\usepackage{array}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{amsmath} 
\usepackage{spverbatim}

\usepackage{caption}
\renewcommand{\lstlistingname}{Программа} % заголовок листингов кода

\lstdefinestyle{my_style}{
    extendedchars=\true,
    keepspaces=true,
    basicstyle=\scriptsize,		    % размер шрифтов, используемых для кода
    numbers=left,					% располоение нумерации строк
    numberstyle=\scriptsize,		% размер шрифтов, используемых для номеров строк
    stepnumber=1,					% шаг между двумя номерами строк. Если он равен 1, каждая строка будет пронумерована
    numbersep=5pt,					% как далеко номера строк от кода
    backgroundcolor=\color{white},	% выберите цвет фона. Необходимо добавить \usepackage{color}
    showspaces=false				% показывать пробелы, добавляя подчеркивания
    showstringspaces=false,			% подчеркивание пробелов в строках
    showtabs=false,					% показывать вкладки в строках, добавляя особые подчеркивания
    frame=rl,           		    % добавляет рамку вокруг кода
    tabsize=2,						% устанавливает размер табуляции по умолчанию в 2 пробела
    captionpos=b,					% устанавливает заголовок-положение снизу
    breaklines=true,				% наборы автоматическая линия разрыва
    breakatwhitespace=false,		% устанавливает, должны ли автоматические разрывы происходить только в пробелах
    escapeinside={\%*}{*)},			% если вы хотите добавить комментарий в коде
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\lstset{style=my_style}

\renewcommand{\rmdefault}{cmss}
\renewcommand{\ttdefault}{cmss}

\usepackage[left=2cm,right=2cm,
top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\begin{document}	% начало документа

\begin{titlepage}	% начало титульной страницы

	\begin{center}		% выравнивание по центру

		\largeФедеральное государственное автономное образовательное учреждение высшего образования «Санкт-Петербургский
        политехнический университет Петра Великого» \\
		\large Институт компьютерных наук и технологий \\
		\large Кафедра компьютерных систем и программных технологий\\[2cm]
		% название института, затем отступ 6см
		
	    \vfill
		\hugeТелекоммуникационные технологии\\[0.5cm] % название работы, затем отступ 0,5см
		\large Лабораторная работа №8:\\
		Модель телекоммуникационного канала\\[4.8cm]

	\end{center}

	\begin{flushright} % выравнивание по правому краю
		\begin{minipage}{0.25\textwidth} % врезка в половину ширины текста
			\begin{flushleft} % выровнять её содержимое по левому краю

				\large\textbf{Работу выполнил:}\\
				\large Сергеев ~А.А.\\
				\large {Группа:} 33531/2\\
				
				\large \textbf{Преподаватель:}\\
				\large Богач ~Н.В.\\

			\end{flushleft}
		\end{minipage}
	\end{flushright}
	
	\vfill % заполнить всё доступное ниже пространство

	\begin{center}
	\large Санкт-Петербург\\
	\large \the\year % вывести дату
	\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы
\vfill % заполнить всё доступное ниже пространство

% Содержание
\tableofcontents
\newpage
\section{Цель}
Создать модель телекоммуникационного канала.
\section{Постановка задачи}
Пакетный сигнал длительностью $200$ мкс состоит из $64$ бит полезной информации и $8$ нулевых tail-бит. В нулевом
$16$-битном слове пакета передается ID, в первом -- период излучения в мс, во втором -- сквозной номер пакета, в третьем
-- контрольная сумма (CRC-16). На передающей стороне пакет сформированный таким образом проходит следующие этапы обработки:
\begin{enumerate}
    \item Помехоустойчивое кодирование сверточным кодом с образующими полиномами $753$, $561$ (octal) и кодовым
          ограничением $9$. На выходе кодера количество бит становится равным $144$.
    \item Перемежение бит. Количество бит на этом этапе остается неизменным.
    \item Модуляция символов. На этом этапе пакет из $144$ полученных с выхода перемежителя бит разбивается на $24$
        символа из $6$ бит. Генерируется таблица функций Уолша длиной $64$ бита. Каждый $6$-битный символ заменяется
        последовательностью Уолша, номер которой равен значению данных $6$-ти бит. Т.о. на выходе модулятора получается
        $24*64=1536$ знаковых символов.
    \item Прямое расширение спектра. Полученная последовательность из $1536$ символов периодически умножается с учетом
        знака на ПСП длиной $511$ символов. Далее к началу сформированного символьного пакета прикрепляется
        немодулированная ПСП. Т.о. символьная длина становится равной $2047$. Далее полученные символы модулируются методом BPSK.
\end{enumerate}
По имеющейся записи сигнала из эфира и коду модели передатчика создать модель приемника, в которой найти позицию начала
пакета и, выполнив операции демодуляции, деперемежения и декодирования, получить передаваемые параметры: ID, период и
номер пакета. Запись сделана с передискретизацией 2, т.е. одному BPSK символу соответствуют 2 лежащих друг за другом
отсчета в файле.
Известно, что $ID=4$, период $100$ мс, номер пакета $373$. Запись сделана с передискретизацией $2$, т.е. одному BPSK
символу соответствуют $2$ лежащих друг за другом отсчета в файле. Запись сделана на нулевой частоте и представляет из
себя последовательность $32$-х битных комплексных отсчетов, где младшие $16$ бит вещественная часть, старшие $16$ бит
-- мнимая часть.
\section{Ход работы}
\subsection{Помехоустойчивое кодирование}
Помехоустойчивое кодирование сверточным кодом с образующими полиномами 755, 561 (octal) и кодовым ограничением 9:
\begin{lstlisting}
trellis = poly2trellis(9, [753 561]);
convolved_signal = convenc(data, trellis);
\end{lstlisting}
Функция $poly2trellis$ принимает в качестве аргументов кодовое ограничение и образующие полиномы, возвращая структуру
$trellis$, с помощью которой в последующем методе $convenc$ происходит кодирование сообщения.
Метод $convenc$ осуществляет само кодирование, принимая в качестве аргументов изначальное сообщение и структуру
$trellis$. Каждый символ в исходном сообщении состоит из $\log_2(trellis.numInputSymbols)$, в закодированном --
из $\log_2(trellis.numOutputSymbols)$.
Размер исходного сообщения -- $72$ бита, длина закодированных данных -- $144$ бита.
\newpage
\subsection{Перемежение бит}
На этом этапе количество бит остаётся неизменным. На этом этапе происходит процесс перестановки бит в сообщении,
чтобы избежать последовательных ошибок при кодировании. Таблица перемежения -- это перестановка чисел от 0 до 143
(по длине сообщения).
\begin{lstlisting}
interleaver = int16([  0; 133; 122; 111; 100;  89;  78;  67;  56;  45;  34;  23;
                      12;   1; 134; 123; 112; 101;  90;  79;  68;  57;  46;  35;
                      24;  13;   2; 135; 124; 113; 102;  91;  80;  69;  58;  47;
                      36;  25;  14;   3; 136; 125; 114; 103;  92;  81;  70;  59; 
                      48;  37;  26;  15;   4; 137; 126; 115; 104;  93;  82;  71;
                      60;  49;  38;  27;  16;   5; 138; 127; 116; 105;  94;  83; 
                      72;  61;  50;  39;  28;  17;   6; 139; 128; 117; 106;  95;
                      84;  73;  62;  51;  40;  29;  18;   7; 140; 129; 118; 107; 
                      96;  85;  74;  63;  52;  41;  30;  19;   8; 141; 130; 119;
                     108;  97;  86;  75;  64;  53;  42;  31;  20;   9; 142; 131;
                     120; 109;  98;  87;  76;  65;  54;  43;  32;  21;  10; 143; 
                     132; 121; 110;  99;  88;  77;  66;  55;  44;  33;  22;  11])

interleaved_signal = convolved_signal(interleaver+1);
\end{lstlisting}
\subsection{Модуляция}
Сначала полученные после перемежения $144$ бита разбиваются на $24$ символа из $6$ бит. Затем генерируется таблицу
функций Уолша длиной 64 бита. Для этого каждый 6-битный символ заменяется последовательностью Уолша, номер которой
равен значению данных 6-ти бит.
Функции Уолша -- это семейство функций, образующих ортогональную систему, принимающих на всей области определения
значения $1$ и $-1$.
\begin{lstlisting}
signal_matrix = reshape(interleaved_signal(1:N*2), [N*2/6, 6]);
y = int16(hadamard(64));
row_number = int16(zeros(1, N*2/6));
for k=1:N*2/6
    line = signal_matrix(k,:);
    row_number(k) = bi2de(line) + 1;
end

signal = y(row_number, :);
signal_to_modulate = reshape(signal', 1, []);
\end{lstlisting}
После этого на выходе получаем $144\cdot 6=1536$ знаковых символов.
\subsection{Прямое расширение спектра}
Расширение спектра производится методом прямой последовательности, повышая тактовую частоту модуляции. Каждому символу
из сообщения ставится в соответствие некоторая достаточно длинная псевдослучайная последовательность. Здесь берется ПСП
длиной 511 символов:\\
\begin{lstlisting}
PRS = int16([1;  1;  1;  1;  1;  1; -1; -1; -1; -1;  1;  1;  1;  1; -1;  1;
             1;  1; -1; -1; -1; -1;  1; -1;  1;  1; -1; -1;  1;  1; -1;  1;
             1; -1;  1;  1;  1;  1; -1;  1; -1; -1; -1; -1;  1;  1;  1; -1;
            -1;  1;  1; -1; -1; -1; -1;  1; -1; -1;  1; -1; -1; -1;  1; -1;
             1; -1;  1;  1;  1; -1;  1; -1;  1;  1;  1;  1; -1; -1;  1; -1;
            -1;  1; -1;  1;  1;  1; -1; -1;  1;  1;  1; -1; -1; -1; -1; -1;
            -1;  1;  1;  1; -1;  1;  1;  1; -1;  1; -1; -1;  1;  1;  1;  1;
            -1;  1; -1;  1; -1; -1;  1; -1;  1; -1; -1; -1; -1; -1; -1;  1;
            -1;  1; -1;  1; -1;  1; -1;  1;  1;  1;  1;  1; -1;  1; -1;  1;
             1; -1;  1; -1; -1; -1; -1; -1;  1;  1; -1;  1;  1;  1; -1;  1;
             1; -1;  1;  1; -1;  1; -1;  1;  1; -1; -1; -1; -1; -1;  1; -1;
             1;  1;  1; -1;  1;  1;  1;  1;  1; -1; -1; -1;  1;  1;  1;  1;
            -1; -1;  1;  1; -1;  1; -1; -1;  1;  1; -1;  1; -1;  1;  1;  1;
            -1; -1; -1;  1;  1; -1;  1; -1; -1; -1;  1; -1;  1;  1;  1;  1;
             1;  1;  1; -1;  1; -1; -1;  1; -1;  1;  1; -1; -1; -1;  1; -1;
             1; -1; -1;  1;  1; -1; -1; -1;  1;  1; -1; -1; -1; -1; -1; -1;
            -1;  1;  1; -1; -1;  1;  1; -1; -1;  1; -1;  1; -1;  1;  1; -1;
            -1;  1; -1; -1;  1;  1;  1;  1;  1;  1; -1;  1;  1; -1;  1; -1;
            -1;  1; -1; -1;  1; -1; -1;  1;  1; -1;  1;  1;  1;  1;  1;  1;
            -1; -1;  1; -1;  1;  1; -1;  1; -1;  1; -1; -1; -1; -1;  1; -1;
             1; -1; -1; -1;  1; -1; -1;  1;  1;  1; -1;  1;  1; -1; -1;  1;
            -1;  1;  1;  1;  1; -1;  1;  1; -1; -1; -1; -1;  1;  1; -1;  1;
            -1;  1; -1;  1; -1; -1;  1;  1;  1; -1; -1;  1; -1; -1; -1; -1;
             1;  1; -1; -1; -1;  1; -1; -1; -1; -1;  1; -1; -1; -1; -1; -1;
            -1; -1; -1;  1; -1; -1; -1;  1; -1; -1; -1;  1;  1; -1; -1;  1;
            -1; -1; -1;  1;  1;  1; -1;  1; -1;  1; -1;  1;  1; -1;  1;  1;
            -1; -1; -1;  1;  1;  1; -1; -1; -1;  1; -1; -1;  1; -1;  1; -1;
             1; -1; -1; -1;  1;  1; -1;  1;  1; -1; -1;  1;  1;  1;  1;  1;
            -1; -1;  1;  1;  1;  1; -1; -1; -1;  1; -1;  1;  1; -1;  1;  1;
             1; -1; -1;  1; -1;  1; -1; -1;  1; -1; -1; -1; -1; -1;  1; -1;
            -1;  1;  1; -1; -1;  1;  1;  1; -1;  1; -1; -1; -1;  1;  1;  1;
             1;  1; -1;  1;  1;  1;  1; -1; -1; -1; -1; -1;  1;  1;  1  ]);
             
n_repeat = int16(length(signal_to_modulate) / length(PRS'));
n_compl  = length(signal_to_modulate) - length(PRS') * n_repeat; 

signal_to_modulate = signal_to_modulate .* [repmat(PRS', 1, n_repeat), PRS(1:n_compl)'];
\end{lstlisting}
И к началу сформированной последовательности добавляется немодулированная ПСП:
\begin{lstlisting}
signal_to_modulate = [PRS', signal_to_modulate];
\end{lstlisting}
В конце этого этапа мы имеем сигнал длиной $1747$ символов.
\subsection{BPSK}
На этом этапе прозводится модуляция методом BPSK. Запись сделана с передискретизацией $2$. Запись сделана на нулевой
частоте и представляет из себя последовательность 32-битных комплексных отсчетов, где младшие 16 бит вещественная
часть, а старшие -- мнимая.
\begin{lstlisting}
IQ = pskmod(double(signal_to_modulate), 2);

IQ_oversampled = [IQ, IQ]; 
IQ_im_part=imag(IQ_oversampled);
IQ_re_part=real(IQ_oversampled);
IQ_record = [IQ_re_part, IQ_im_part];
\end{lstlisting}
\subsection{CRC}
CRC высчитывается следующим образом:
\begin{lstlisting}
crc_gen = crc.generator('Polynomial', '0x1021');
crc = generate(crc_gen, data');
crc_send = crc(73:88);
\end{lstlisting}
\subsection{Декодирование}
Для сверточного декодирования используется алгоритм Витерби -- рекуррентная процедура, направленная на поиск пути по
кодовой решетке, ближайшего к принимаемой последовательности.
Пример использования сверточного кодирования и декодирования алгоритмом Витерби представлен ниже:
\begin{lstlisting}
trellis = poly2trellis(4,[7 10]);
data = [1 1 1 1 0 1 1 1 0 1 1 0 1 1 0];

code = convenc(data, trellis);
decoded = vitdec(code, trellis, 3, 'trunc', 'hard');
\end{lstlisting}
Вероятность ошибки в этом случае:
\begin{lstlisting}
[n1,r1] = biterr(decoded(3+1:end),data(1:end-3));
\end{lstlisting}
Получаем вероятность, равную $0.25$.
\section{Вывод}
В работе была представлена модель телекоммуникационного канала, а также этапы обработки сигнала у передатчика.
Было рассмотрено помехоустойчивое кодирование сверточным кодом, а также декодирование сигнала алгоритмом Витерби.
Особенность сверточных кодов в том, что они работают с сигналом как со сплошным потоком данных. Декодирование таких
кодов обычно происходит с использованием алгоритма Витерби, который пытается восстановить переданную последовательность
согласно критерию максимального правдоподобия. \\
Сверточные коды эффективно работают в канале с белым шумом, но плохо справляются с пакетами ошибок.
\end{document}
